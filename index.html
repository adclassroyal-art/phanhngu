<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Trái tim ❤️</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;background:#000}
    canvas{display:block;width:100vw;height:100vh}
    .tip{
      position:fixed;left:50%;bottom:18px;transform:translateX(-50%);
      color:rgba(255,255,255,.75);
      font: 14px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      text-align:center; user-select:none; pointer-events:none;
      text-shadow:0 2px 10px rgba(0,0,0,.6);
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="tip">Chạm/click để “thổi” thêm sao ✨</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  let W=0,H=0, DPR=1;
  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W; canvas.height = H;
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // ---------- Helpers ----------
  const rand = (a,b)=>a+Math.random()*(b-a);
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));

  // ---------- Galaxy background (cheap but pretty) ----------
  const bgStars = [];
  function seedBackground(){
    bgStars.length = 0;
    const n = Math.floor((innerWidth*innerHeight)/9000);
    for(let i=0;i<n;i++){
      bgStars.push({
        x: Math.random()*W,
        y: Math.random()*H,
        r: rand(0.4, 1.6)*DPR,
        t: Math.random()*Math.PI*2,
        s: rand(0.004, 0.018),
        a: rand(0.15, 0.9)
      });
    }
  }
  seedBackground();
  addEventListener('resize', seedBackground, {passive:true});

  function drawBackground(time){
    // deep space gradient
    const g = ctx.createRadialGradient(W*0.25,H*0.2,0, W*0.25,H*0.2, Math.max(W,H)*0.9);
    g.addColorStop(0,   'rgb(18,8,35)');
    g.addColorStop(0.5, 'rgb(3,6,18)');
    g.addColorStop(1,   'rgb(0,0,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // nebula haze layers
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    for(let i=0;i<3;i++){
      const cx = (0.2+i*0.32)*W;
      const cy = (0.25+i*0.18)*H;
      const rr = (0.55+i*0.15)*Math.max(W,H);
      const gg = ctx.createRadialGradient(cx,cy,0,cx,cy,rr);
      gg.addColorStop(0, `rgba(${40+i*25},${10+i*10},${80+i*35},0.18)`);
      gg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = gg;
      ctx.beginPath(); ctx.arc(cx,cy,rr,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();

    // twinkling bg stars
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for(const s of bgStars){
      const tw = 0.55 + 0.45*Math.sin(time*s.s + s.t);
      ctx.globalAlpha = s.a * tw;
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  // ---------- Heart shape sampling ----------
  // Implicit heart curve -> sample points and map into screen space.
  function heartPoint(t){
    // classic parametric heart
    const x = 16*Math.pow(Math.sin(t),3);
    const y = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
    return {x, y};
  }

  // create target points that form a heart
  const targets = [];
  function buildTargets(){
    targets.length = 0;
    const count = Math.floor(900 * (Math.min(innerWidth, innerHeight)/700));
    const scale = Math.min(W,H) * 0.028; // base scale
    for(let i=0;i<count;i++){
      const t = (i/count) * Math.PI*2;
      // jitter around curve to create "star field" thickness
      const p = heartPoint(t);
      const j = rand(-1,1);
      const k = rand(-1,1);
      const thick = 0.9 + 1.2*Math.random();
      targets.push({
        // normalized heart coords
        hx: (p.x + j*thick)*scale,
        hy: (-p.y + k*thick)*scale, // flip y for canvas
      });
    }
  }
  buildTargets();
  addEventListener('resize', buildTargets, {passive:true});

  // ---------- Particles (stars that form heart) ----------
  const stars = [];
  const center = () => ({ cx: W*0.5, cy: H*0.52 });

  function spawnStars(){
    stars.length = 0;
    const {cx, cy} = center();
    for(let i=0;i<targets.length;i++){
      const tar = targets[i];
      // start scattered in space
      const ang = Math.random()*Math.PI*2;
      const rad = rand(0.08, 0.65) * Math.min(W,H);
      const x0 = cx + Math.cos(ang)*rad;
      const y0 = cy + Math.sin(ang)*rad;

      stars.push({
        x: x0, y: y0,
        vx: rand(-0.3,0.3)*DPR, vy: rand(-0.3,0.3)*DPR,
        // personal offsets to thicken heart fill
        ox: rand(-10,10)*DPR, oy: rand(-10,10)*DPR,
        // twinkle phase
        ph: Math.random()*Math.PI*2,
        // base brightness & size
        b: rand(0.25, 0.9),
        r: rand(0.6, 1.9)*DPR,
        // which target
        tx: tar.hx, ty: tar.hy,
      });
    }
  }
  spawnStars();
  addEventListener('resize', spawnStars, {passive:true});

  // extra sparkle particles on click
  const sparkles = [];
  function burst(x,y){
    for(let i=0;i<80;i++){
      const a = Math.random()*Math.PI*2;
      const sp = rand(0.6, 4.2)*DPR;
      sparkles.push({
        x,y,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp,
        life: rand(25,55),
        r: rand(0.6,1.8)*DPR,
        ph: Math.random()*Math.PI*2
      });
    }
  }
  addEventListener('pointerdown', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX-rect.left)*DPR;
    const y = (e.clientY-rect.top)*DPR;
    burst(x,y);
  }, {passive:true});

  // ---------- Rendering: tiny star "cross" + glow ----------
  function drawStar(x,y,rad,alpha){
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x,y,rad,0,Math.PI*2);
    ctx.fill();

    // cross sparkle
    ctx.globalAlpha = alpha*0.55;
    ctx.beginPath();
    ctx.moveTo(x-rad*3, y);
    ctx.lineTo(x+rad*3, y);
    ctx.moveTo(x, y-rad*3);
    ctx.lineTo(x, y+rad*3);
    ctx.lineWidth = Math.max(1, rad*0.9);
    ctx.strokeStyle = 'white';
    ctx.stroke();
    ctx.restore();
  }

  function drawSparkles(time){
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for(let i=sparkles.length-1;i>=0;i--){
      const p = sparkles[i];
      p.x += p.vx; p.y += p.vy;
      p.vx *= 0.98; p.vy *= 0.98;
      p.life -= 1;
      const a = clamp(p.life/55, 0, 1);
      const tw = 0.6 + 0.4*Math.sin(time*0.03 + p.ph);
      drawStar(p.x,p.y,p.r, a*tw);
      if(p.life<=0) sparkles.splice(i,1);
    }
    ctx.restore();
    ctx.globalCompositeOperation = 'source-over';
  }

  // ---------- Animation loop (beating heart) ----------
  let t0 = performance.now();
  function frame(now){
    const time = now - t0;

    drawBackground(time);

    // heartbeat (scale pulse) + slight rotation wobble
    const beat = 1 + 0.10*Math.sin(time*0.006) + 0.04*Math.sin(time*0.013);
    const wob  = 0.10*Math.sin(time*0.0015);

    const {cx, cy} = center();

    // glow layer behind heart
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    const glow = ctx.createRadialGradient(cx,cy,0,cx,cy, Math.min(W,H)*0.28);
    glow.addColorStop(0, `rgba(255,80,160,0.18)`);
    glow.addColorStop(0.35, `rgba(160,120,255,0.12)`);
    glow.addColorStop(1, `rgba(0,0,0,0)`);
    ctx.fillStyle = glow;
    ctx.beginPath(); ctx.arc(cx,cy,Math.min(W,H)*0.28,0,Math.PI*2); ctx.fill();
    ctx.restore();

    // update/draw heart-stars
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';

    // attraction strength
    const k = 0.018 * DPR;

    for(const s of stars){
      // target position for this star (heart)
      const tx = cx + (s.tx*beat) + s.ox;
      const ty = cy + (s.ty*beat) + s.oy;

      // spring attraction + tiny drift
      const ax = (tx - s.x) * k;
      const ay = (ty - s.y) * k;

      s.vx = (s.vx + ax) * 0.92;
      s.vy = (s.vy + ay) * 0.92;

      // wobble makes it feel alive
      s.x += s.vx + Math.sin(time*0.001 + s.ph)*0.08*DPR + wob*0.12*DPR;
      s.y += s.vy + Math.cos(time*0.0012 + s.ph)*0.08*DPR - wob*0.08*DPR;

      // twinkle
      const tw = 0.55 + 0.45*Math.sin(time*0.01 + s.ph*3.0);
      const a  = s.b * tw;

      // draw
      drawStar(s.x, s.y, s.r*(0.9+0.25*tw), a);
    }

    ctx.restore();
    ctx.globalCompositeOperation = 'source-over';

    // sparkles on click
    drawSparkles(time);

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
